用python实现opencv照书上的代码打进去报错NameError
这是代码
import cv2
import numpy
import time
class CaptureManager(object):
<code>def __init__(self,capture,previewWindowManager = None,shouldMirrorPreview = False):

    self.previewWindowManager = previewWindowManager
    self.shouldMirrorPreview = shouldMirrorPreview

    self._capture = capture
    self._channel = 0
    self._enteredFrame = False
    self._frame = None
    self._imageFilename = None
    self._videoFilename = None
    self._videoEncoding = None
    self._videoWriter = None

    self._startTime = None
    self._framesElapsed = long(0)
    self._fpsEstimate = None

@property
def channel(self):
    return self._channel

@channel.setter
def channel(self,value):
    if self._channel != value:
        self._channel = value
        self.frame = None

@property
def frame(self):
    if self._enteredFrame and self._frame is None:
        _, self.frame = self._capture.retrieve()
    return self.frame

@property
def isWritingImage(self):

    return self._imageFilename is not None

@property
def isWritingVideo(self):
    return self._videoFilename is not None


def enterFrame(self):
    """Capture the next frame,if any."""

    #but first,check that any previous frame was exited.
    assert not self._enteredFrame,\
           'previous enterFrame() had no maching exitFrame()'

    if self._capture is not None:
        self._enteredFrame = self._capture.grab()

def exitFrame(self):
    """Draw to the window. Write to files.Release the frame."""

    #Check whether any grabbed frame is retriveable.
    #The getter may retrieve and cache the frame.
    if self.frame is None:
        self._enteredFrame = False
        return

    #Update the FPS estimate and related variables.
    if self._framesElapsed == 0:
        self._startTime = time.time()
    else:
        timeElapsed = time.time() - self.startTime
    self.fpsEstimate = self._framesElapsed / timeElapsed
self._framesElapsed += 1

#Draw to the Window,if any.
if self.previewWindowManager is not None:
    if self.showldMirrorPreview:
        mirroredFrame = numpy.fliplr(self._frame).copy()
        self.previewWindowManager.show(mirroredFrame)
    else:
        self.previewWindowManager.show(self._frame)

#Write to the image file,if any.
if self.isWrintingImage:
    cv2.imwrite(self.imageFilename,self._frame)
    self._imageFilename = None

#Write to the video file,if any.
    self._writeVideoFrame()

#Release the frame.
    self._frame = None
    self.enteredFrame = False

def writeImage(self,filename):
   """Write the next exited frame to an image file."""
   self._imageFilename = filename

def startWritingVideo(self,filename,encoding = cv2.VideoWriter_fourcc('I','4','2','0')):
    """Start writing exited frames to a video file."""
    self._videoFilename = filename
    self._videoEnchding = None
    self._videoWriter = None

def _writeVideoFrame(self):

    if not self.isWritingVideo:
        return

    if self._videoWriter is None:
        fps = self._capture.get(cv2.CAP_PROP_FPS)
        if fps == 0.0:
            #The capture's FPS is unknown so use an entimate.
            if self._framesElapsed < 20:
                #Wait until more frames frames elapse so that the estimate is more stable.
                return
            else:
                fps = self._fpsEstimate
        size = (int(self._capture.get(cv2.CAP_PROP_FRAME_WIDTH)),int(self._capture.get(cv2.CAP_FRAME_HEIGHT)))
        self._videoWriter = cv2.VideoWriter(self._videoFilename,self._videoEncoding,fps,size)
    self._videoWriter.write(self._frame)
</code>
class WindowManager(object):
    def init(self,windowName,keypressCallback = None):
        self.keypressCallback = keypressCallback
<code>    self._windowName = windowName
    self._isWindowCreated = False

@property
def isWindowCreated(self):
    return self._iswindowCreated

def creatWindow(self):
    cv2.namedWindow(self._windowName)
    self._isWindowCreated = True

def show(self,frame):
    cv2.imshow(self._windowName,frame)

def destroyWindow(self):
    cv2.destroyWindow(self._windowName)
    self._isWindowCreated = False

def processEvents(self):
    keycode = cv2.waitKey(1)
    if self.keypressCallback is not None and  keycode != -1:
        #Discard any non-ASCII info encoded by GTY.
        keycode &= 0xFF
        self.keypressCallback(keycode)
</code>
运行一下报错
Traceback (most recent call last):
  File "G:\opencv\usrcold\managers.py", line 5, in 
    class CaptureManager(object):
  File "G:\opencv\usrcold\managers.py", line 76, in CaptureManager
    self._framesElapsed += 1
NameError: name 'self' is not defined
为什么~ 
----------------------------------------------------------------------------------------------------
<code>


import cv2
import numpy as np
import time


class CaptureManager(object):
    def __init__(self,capture,previewWindowManger = None,shouldMirrorPreview = False):
        self.previewWindowManger = previewWindowManger
        self.shouldMirrorPreview = shouldMirrorPreview

        self._capture = capture
        self._channel = 0
        self._enteredFrame = False

        self._frame = None 
        self._imageFilename = None
        self._videoFilename = None
        self._videoEncoding = None
        self._videoWriter = None

        self._startTime = None
        self._framesElapsed = 0
        self._fpsEstimate = None

    @property
    def channel(self):
        return self._channel 

    @channel.setter
    def channel(self,value):
        if self._channel != value:
            self._channel = value
            self._frame = None
    @property
    def frame(self):
        if self._enteredFrame and self._frame is None:
            _,self._frame = self._capture.retrieve()
        return self._frame


    @property
    def isWritingImage(self):
        return self._imageFilename is not None
    @property
    def isWritingVideo(self):
        return self._videoFilename is not None
    def enterFrame (self):
        assert not self._enteredFrame,\
        'previous enterFrame() had no matching enterFrame()'
        if self._capture is not None:
            self._enteredFrame = self._capture.grab()

    def exitFrame (self):
        if self._frame is None:
            self._enteredFrame = False
            return 

        if self._framesElapsed == 0:
            self.startTime = time.time()
        else:
            timeElapsed = time.time()-self.startTime
            self._fpsEstimate = self._framesElapsed/timeElapsed
        self._framesElapsed += 1

        if self.previewWindowManger is not None:
            if self.shouldMirrorPreview:
                mirroredFrame = np.fliplr(self._frame).copy()
                self.previewWindowManger.show(mirroredFrame)
            else:
                self.previewWindowManger.show(self._frame)

        if self.isWritingImage:
            cv2.imwrite(self._imageFilename,self._frame)
            self._imageFilename = None
        self._writeVideoFrame()

        self._frame = None
        self._enteredFrame = False

    def writeImage(self,filename):
        self._imageFilename = filename

    def startWritingVideo(self,filename,encoding = cv2.VideoWriter_fourcc('i','4','2','0')):
        self._videoFilename = filename
        self._videoEncoding = encoding

    def stopWritingVideo(self):
        self._videoFilename = None
        self._videoEncoding = None
        self._videoWriter = None
    def _writeVideoFrame(self):

        if not self.isWritingVideo:
            return 
        if self._videoWriter is None:
            fps = self._capture.get(cv2.CAP_PROP_FPS)
            if fps == 0.0:
                if self._frameElapsed <20:
                    return 
                else:
                    fps = self._fpsEstimate
            size =(int(self._capture.get(cv2.CAP_PROP_FRAME_WIDTH)),int(self._capture.get(cv2.CAP_PROP_FRAME_HEIGHT)))
            self._videoWriter = cv2.VideoWriter(self._videoFilename,self._videoEncoding,fps,size)
        self._videoWriter.write(self._frame)

class WindowManager(object):
    def __init__(self,windowName,keypressCallback = None):
        self.keypressCallback = keypressCallback
        self._windowName = windowName
        self._isWindowCreated = False

    @property
    def isWindowCreated(self):
        return self._isWindowCreated 
    def createWindow(self):
        cv2.namedWindow(self._windowName)
        self._isWindowCreated = True

    def show(self,frame):
        cv2.imshow(self._windowName,frame)

    def destroyWindow(self):
        cv2.destroyWindow(self._windowName)
        self._isWindowCreated = False
    def processEvents(self):
        keycode = cv2.waitKey(1)
        if self.keypressCallback is not None and keycode != -1:
            keycode &= 0xff
            self.keypressCallback(keycode)



</code>
我今天也遇到这个问题了,最后这样就好了   
<code></code>