C++中请问如何实现delete this以后置零的需求。
因为源代码中有大量的delete this，会造成很多意想不到的问题，所以我希望把结构改为如下代码，将delete this改为killMe。有大神能帮忙看看下面的代码有什么问题吗？走到killme中的delete me;的时候，它不进析构函数。然后if(0 != m)该判断始终不为0，于是会造成再次调用Do();，导致程序崩溃。谢谢！
<code>#include "stdafx.h"
#include <iostream>

using namespace std;

class Me;

void killMe(Me *me)
{
    delete me;
    me = 0;
}

class Me
{
public:
    Me()
    {
            i = new int(10);
    };

    virtual ~Me()
    {
            delete i;
    };

    void Do()
    {
            killMe(this);
    };

    int *i;
};

int _tmain(int argc, _TCHAR* argv[])
{
    Me *m = new Me();

    m->Do();

    if(0 != m)
    {
            m->Do();
    }
    else
    {
            cout<<"Do skip"<<endl;
    }

    return 0;
}
</code> 
----------------------------------------------------------------------------------------------------
/*照我这样写可以解决你的问题,后面我解释*/
//Me.h 头文件
#include 
using namespace std;
class Me
{
public:
    Me()
    {
        cout << "构造" << endl;
        i = new int(10);
    };
<code>virtual ~Me()
{
    cout << "析构" << endl;
    delete i;
};

void Do();


int *i;
</code>
};
/*源文件*/
#if 1
#include 
#include "Me.h"
using namespace std;
void killMe(Me *me)
{
    delete me;     //之所以没有调用析构函数是因为此时的me是this指针的一份拷贝,由于Me类此时还没有完整地定义,所以不能够访问其成员,
    me = 0;
    //int a = 0;
    //me->i = &a;
    cout << "KillMe " << endl;
}
void Me::Do()
{
    cout << "Do" << endl;
    killMe(this);
};
int main()
{
    Me *m = new Me();
<code>m->Do();

if (0 != m)
{
    m->Do();
}
else
{
    cout << "Do skip" << endl;
}
/*A *a = new A();
delete a;  //掉析构 。。。
a = NULL;*/

return 0;
</code>
}
#endif
试试我的代码...